"""
正则表达式
"""

"""元字符"""
# \b  元字符 - metacharacter  单词的分界处，它只匹配一个位置   匹配 hi - \bhi\b
# 匹配 hi后面有Lucy - \bhi\b.*\bLucy\b  -- 先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy

# .   匹配除了换行符以外的任意字符
# *   它代表的不是字符，也不是位置，而是数量 —— 它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配
# .*  连在一起就意味着任意数量的不包含换行的字符

# \d  匹配一位数字
# 0\d\d-\d\d\d\d\d\d\d\d   --  以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字
# 0\d{2}-\d{8}  \d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次)。

# \s  匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等
# \w  匹配字母，数字，下划线，汉字等。

# \ba\w*\b   匹配以字母a开头的单词，然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)
# \d+        匹配1个或多个连续的数字 -- 这里的 + 是和 * 类似，不同的是 * 匹配重复任意次(可能是0次)，而 + 匹配至少一次
# \b\w{6}\b  匹配刚好6个字符的单词

# 元字符是 ^ 和 $ 都匹配一个位置，这和 \b 有点类似； ^ 匹配你要用来查找的字符串的开头， $ 匹配结尾
# ^\d{5,12}$  --  填写的QQ号必须为5位到12位数字

"""转义字符"""
# . -- \.   使用\来取消这些字符的特殊意义
# * -- \*
# \ -- \\
# deerchao\.c n匹配 deerchao.cn，  C:\\Windows 匹配 C:\Windows

"""通配符 - 重复"""
# *       零次或多次  ≥ 0
# +       一次或多次  ≥ 1
# ?       零次或一次  0 or 1
# {n}     重复n次
# {n,}    重复n次或更多次
# {n,m}   重复n到m次

# Windows\d+   匹配Windows后面跟1个或多个数字
# ^\w+         匹配整个字符串的第一个单词

"""字符类"""
# [aeiou]       匹配任何一个英文元音字母
# [0-9]         表的含意与\d就是完全一致的 - 匹配一位数字
# [a-z0-9A-Z_]  完全等同于\w（如果只考虑英文的话）

# \(?0\d{2}[) -]?\d{8}  -- (010)88886666，或022-22334455，或02912345678等
# 首先是一个转义字符\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})
# 然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})

"""分枝条件"""
# 刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，需要用到分枝条件
# 正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用 | 把不同的规则分隔开

# 0\d{2}-\d{8}|0\d{3}-\d{7}  匹配两种以连字号分隔的电话号码 -- 010-12345678 或 0376-2233445
# \(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}  其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔
# \d{5}-\d{4}|\d{5}  匹配美国的邮政编码 -- 美国邮编的规则是5位数字，或者用连字号间隔的9位数字

"""分组"""
# 可以用小括号来指定子表达式(也叫做分组)
# (\d{1,3}\.){3}\d{1,3}  错误的IP地址匹配表达式
# \d{1,3}匹配1到3位的数字 -- (\d{1,3}\.){3} 匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次  -- 括号内的内容重复三次
# \d{1,3} 最后再加上一个一到三位的数字
# 它也将匹配 256.300.888.999 / 221.221.221.231 这种不可能存在的IP地址

# ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)  正确的IP地址匹配表达式
# ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.) * 3 + (2[0-4]\d|25[0-5]|[01]?\d\d?)
# (234|255|01.) * 3 +  234|255|01

"""反义"""
# 比如想查找除了数字以外，其它任意字符都可以的情况 (限制输入)
# \W         匹配 除了字母，数字，下划线，汉字以外的字符
# \S         匹配 除了空白符以外的字符
# \D         匹配 除了非数字以外的字符
# \B         匹配 不是单词开头或结束的位置
# [^x]       匹配 除了x以外的任意字符
# [^aeiou]   匹配 除了aeiou这几个字母以外的任意字符

# \S+        匹配 不包含空白符的字符串
# <a[^>]+>   匹配 用尖括号括起来的以a开头的字符串。

"""后向引用"""
# 使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理
# 每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推
# 后向引用用于重复搜索前面某个分组匹配的文本。\1 代表分组1匹配的文本

# \b(\w+)\b\s+\1\b  匹配重复的单词, 像go go, 或者kitty kitty
# (\b(\w+)\b)       这个单词会被捕获到编号为1的分组中
# \s+               1个或几个空白符
# 最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)

# 你也可以自己指定子表达式的组名
# (?<Word>\w+)(或者把尖括号换成'也行：(?'Word'\w+)) -- 把 \w+ 的组名指定为Word了
# 要反向引用这个分组捕获的内容，你可以使用 \k<Word>  --  \b(?<Word>\w+)\b\s+\k<Word>\b

# 捕获
# (exp)	        匹配exp,并捕获文本到自动命名的组里
# (?<name>exp)  匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
# (?:exp)	    匹配exp,不捕获匹配的文本，也不给此分组分配组号

"""零宽断言"""
# 这四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西
# 也就是说它们像 \b,^,$ 那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言

# (?=exp)	      匹配exp前面的位置 -- 零宽度正预测先行断言
# \b\w+(?=ing\b)  断言自身出现的位置的后面能匹配表达式exp: 匹配以ing结尾的单词的前面部分(除了ing以外的部分)
# 如查找I'm singing while you're dancing.时，它会匹配sing和danc

# (?<=exp)	 匹配exp后面的位置 -- 零宽度正回顾后发断言
# (?<=\bre)\w+\b  断言自身出现的位置的前面能匹配表达式exp: 匹配以re开头的单词的后半部分(除了re以外的部分)
# 查找reading a book时，它匹配ading

# ((?<=\d)\d{3})+\b  给一个很长的数字中每三位间加一个逗号(从右边加起)

"""负向零宽断言"""
# (?!exp)	         匹配后面跟的不是exp的位置 -- 零宽度负预测先行断言
# \d{3}(?!\d)        断言此位置的后面不能匹配表达式exp: 匹配三位数字，而且这三位数字的后面不能是数字
# \b((?!abc)\w)+\b   匹配不包含连续字符串abc的单词。

# (?<!exp)	         匹配前面不是exp的位置 -- 零宽度负回顾后发断言
# (?<![a-z])\d{7}    断言此位置的前面不能匹配表达式exp: 匹配前面不是小写字母的七位数字
# (?<=<(\w+)>).*(?=<\/\1>)  匹配不包含属性的简单HTML标签内里的内容
# (?<=<(\w+)>) 指定了这样的前缀: 被尖括号括起来的单词(比如可能是<b>)
# 然后是.*(任意的字符串), 最后是一个后缀(?=<\/\1>)
# 注意后缀里的\/，它用到了前面提过的字符转义: \1则是一个反向引用，引用的正是捕获的第一组
# 前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。
# 整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)

"""注释"""
# (?#comment)  这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
# 2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)

# 启用“忽略模式里的空白符”选项: 能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略
#       (?<=    # 断言要匹配的文本的前缀
#       <(\w+)> # 查找尖括号括起来的内容
#               # (即HTML/XML标签)
#       )       # 前缀结束
#       .*      # 匹配任意文本
#       (?=     # 断言要匹配的文本的后缀
#       <\/\1>  # 查找尖括号括起来的内容
#               # 查找尖括号括起来的内容
#       )       # 后缀结束

"""贪婪与懒惰"""
# 贪婪匹配: a.*b -- 匹配最长的以a开始，以b结束的字符串
# 懒惰匹配: .*? -- 匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复

# 懒惰限定符
# *?	   重复任意次，但尽可能少重复
# +?	   重复1次或更多次，但尽可能少重复
# ??	   重复0次或1次，但尽可能少重复
# {n,m}?   重复n到m次，但尽可能少重复
# {n,}?	   重复n次以上，但尽可能少重复

"""处理选项"""
# IgnoreCase(忽略大小写)	            匹配时不区分大小写。
# Multiline(多行模式)	                更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配
# (在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)
# Singleline(单行模式)	            更改.的含义，使它与每一个字符匹配（包括换行符\n）。
# IgnorePatternWhitespace(忽略空白)	忽略表达式中的非转义空白并启用由#标记的注释。
# ExplicitCapture(显式捕获)           仅捕获已被显式命名的组。

"""平衡组/递归匹配"""
# (?'group')         把捕获的内容命名为group,并压入堆栈(Stack)
# (?'-group')        从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
# (?(group)yes|no)   如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
# (?!)               零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

"""
<                   #最外层的左括号
  [^<>]*            #它后面非括号的内容
  (
      (
        (?'Open'<)  #左括号，压入"Open"
        [^<>]*      #左括号后面的内容
      )+
      (
        (?'-Open'>) #右括号，弹出一个"Open"
        [^<>]*      #右括号后面的内容
      )+
  )*
  (?(Open)(?!))     #最外层的右括号前检查
                    #若还有未弹出的"Open"
                    #则匹配失败
>                   #最外层的右括号
"""

# 平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签:
# <div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>.

"""其他"""
# \a                    报警字符(打印它的效果是电脑嘀一声)
# \b	                通常是单词分界位置，但如果在字符类里使用代表退格
# \t	                制表符，Tab
# \r	                回车
# \v	                竖向制表符
# \f	                换页符
# \n	                换行符
# \e	                Escape
# \0nn	                ASCII代码中八进制代码为nn的字符
# \xnn	                ASCII代码中十六进制代码为nn的字符
# \unnnn	            Unicode代码中十六进制代码为nnnn的字符
# \cN	                ASCII控制字符。比如\cC代表Ctrl+C
# \A	                字符串开头(类似^，但不受处理多行选项的影响)
# \Z	                字符串结尾或行尾(不受处理多行选项的影响)
# \z	                字符串结尾(类似$，但不受处理多行选项的影响)
# \G	                当前搜索的开头
# \p{name}	            Unicode中命名为name的字符类，例如\p{IsGreek}
# (?>exp)	            贪婪子表达式
# (?<x>-<y>exp)	        平衡组
# (?im-nsx:exp)	        在子表达式exp中改变处理选项
# (?im-nsx)	            为表达式后面的部分改变处理选项
# (?(exp)yes|no)	    把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no
# (?(exp)yes)           同上，只是使用空表达式作为no
# (?(name)yes|no)	    如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no
# (?(name)yes)          同上，只是使用空表达式作为no
